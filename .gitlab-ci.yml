stages:
  - security
  - quality
  - test
  - deploy

variables:
  SECRET_DETECTION_ENABLED: 'true'
  # Go cache configuration for faster builds
  GOPATH: ${CI_PROJECT_DIR}/.go
  GOCACHE: ${CI_PROJECT_DIR}/.go-cache
  GOLANGCI_LINT_CACHE: ${CI_PROJECT_DIR}/.golangci-cache

include:
  - template: Security/Secret-Detection.gitlab-ci.yml
  - template: Security/SAST.gitlab-ci.yml

# Default cache configuration for Go jobs
.go-cache:
  cache:
    key:
      files:
        - go.sum
    paths:
      - .go/pkg/mod/
      - .go-cache/
    policy: pull

# === SECURITY STAGE ===
# Both security scans run in parallel

secret_detection:
  stage: security
  tags:
    - playground-bravo

semgrep-sast:
  stage: security
  tags:
    - playground-bravo

# === QUALITY STAGE ===
# All quality checks run in parallel

check_secrets:
  stage: quality
  image: apteno/alpine-jq:latest
  tags:
    - playground-bravo
  needs:
    - job: secret_detection
      artifacts: true
  script:
    - |
      if [ ! -f "gl-secret-detection-report.json" ]; then
        echo "Secret detection report not found!"
        exit 1
      fi

      if [ "$(jq '.vulnerabilities | length' gl-secret-detection-report.json)" -gt 0 ]; then
        echo "Secrets detected in the codebase!"
        jq -r '.vulnerabilities[] | "- \(.message) in \(.location.file):\(.location.start_line)"' \
          gl-secret-detection-report.json
        exit 1
      else
        echo "No secrets detected"
      fi

check_sast:
  stage: quality
  image: apteno/alpine-jq:latest
  tags:
    - playground-bravo
  needs:
    - job: semgrep-sast
      artifacts: true
  script:
    - |
      if [ ! -f "gl-sast-report.json" ]; then
        echo "SAST report not found!"
        exit 1
      fi

      VULN_COUNT=$(jq '.vulnerabilities | length' gl-sast-report.json)
      if [ "$VULN_COUNT" -gt 0 ]; then
        echo "SAST vulnerabilities detected!"
        jq -r '.vulnerabilities[] | "- [\(.severity)] \(.name) in \(.location.file):\(.location.start_line)"' \
          gl-sast-report.json
        exit 1
      else
        echo "No SAST vulnerabilities detected"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

lint:
  stage: quality
  image: golangci/golangci-lint:v2.8-alpine
  tags:
    - playground-bravo
  extends: .go-cache
  cache:
    key:
      files:
        - go.sum
        - .golangci.yml
    paths:
      - .go/pkg/mod/
      - .go-cache/
      - .golangci-cache/
    policy: pull-push
  before_script:
    - export GOLANGCI_LINT_CACHE=${GOLANGCI_LINT_CACHE}
  script:
    - golangci-lint run --timeout=5m ./...

# === TEST STAGE ===

test:
  stage: test
  image: golang:1.25-alpine
  tags:
    - playground-bravo
  extends: .go-cache
  cache:
    key:
      files:
        - go.sum
    paths:
      - .go/pkg/mod/
      - .go-cache/
    policy: pull-push
  needs:
    - job: check_secrets
    - job: lint
  services:
    - name: postgres:18-alpine
      alias: postgres
  variables:
    POSTGRES_USER: test
    POSTGRES_PASSWORD: test
    POSTGRES_DB: expense_bot_test
  before_script:
    - export TEST_DATABASE_URL="postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?sslmode=disable"
  script:
    # OPTIMIZED: Increased parallelization from -p 1 to -p 4 (4-8x faster)
    - go test -v -coverprofile=coverage.out -covermode=atomic -p 4 ./...
    # OPTIMIZED: Calculate coverage once and reuse
    - |
      COVERAGE_OUTPUT=$(go tool cover -func=coverage.out)
      echo "$COVERAGE_OUTPUT"
      COVERAGE=$(echo "$COVERAGE_OUTPUT" | grep total | awk '{print $3}' | sed 's/%//')
      THRESHOLD=40
      echo "Coverage: ${COVERAGE}% (threshold: ${THRESHOLD}%)"
      if [ "$(echo "$COVERAGE < $THRESHOLD" | bc)" -eq 1 ]; then
        echo "Coverage ${COVERAGE}% is below threshold ${THRESHOLD}%!"
        exit 1
      fi
  artifacts:
    paths:
      - coverage.out
    expire_in: 1 week
  coverage: '/total:\s+\(statements\)\s+(\d+\.\d+)%/'

# === DEPLOY STAGE ===

deploy:
  stage: deploy
  # OPTIMIZED: Use image with git pre-installed
  image: alpine/git:latest
  tags:
    - playground-bravo
  needs:
    - job: test
    - job: check_sast
  before_script:
    # OPTIMIZED: Only install openssh-client (git already included)
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$DOKKU_SSH_PRIVATE_KEY_B64" | base64 -d | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$DOKKU_HOST_KEY" >> ~/.ssh/known_hosts
  script:
    - git remote add dokku dokku@$DOKKU_HOST:csy-helper-bot || true
    - git push dokku HEAD:main --force
  rules:
    # TODO change back to master once done
    - if: $CI_COMMIT_BRANCH == "unknown"
