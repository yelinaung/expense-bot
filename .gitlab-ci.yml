stages:
  - security
  - quality
  - test
  - deploy
  - release

variables:
  SECRET_DETECTION_ENABLED: 'true'
  # Go cache configuration for faster builds
  GOPATH: ${CI_PROJECT_DIR}/.go
  GOCACHE: ${CI_PROJECT_DIR}/.go-cache
  GOLANGCI_LINT_CACHE: ${CI_PROJECT_DIR}/.golangci-cache

include:
  - template: Security/Secret-Detection.gitlab-ci.yml
  - template: Security/SAST.gitlab-ci.yml

# Default cache configuration for Go jobs
.go-cache:
  cache:
    key:
      files:
        - go.sum
    paths:
      - .go/pkg/mod/
      - .go-cache/
    policy: pull

# === SECURITY STAGE ===
# All security scans run in parallel

secret_detection:
  stage: security
  tags:
    - playground-bravo
  rules:
    - if: $CI_COMMIT_BRANCH
    - if: $CI_COMMIT_TAG

semgrep-sast:
  stage: security
  tags:
    - playground-bravo
  rules:
    - if: $CI_COMMIT_BRANCH
    - if: $CI_COMMIT_TAG

gosec:
  stage: security
  image: golang:1.26-alpine
  tags:
    - playground-bravo
  extends: .go-cache
  before_script:
    - export PATH="$GOPATH/bin:$PATH"
    - go install github.com/securego/gosec/v2/cmd/gosec@latest
  script:
    - gosec -exclude-dir=.go ./...

# === QUALITY STAGE ===
# All quality checks run in parallel

check_secrets:
  stage: quality
  image: apteno/alpine-jq:latest
  tags:
    - playground-bravo
  needs:
    - job: secret_detection
      artifacts: true
  script:
    - |
      if [ ! -f "gl-secret-detection-report.json" ]; then
        echo "Secret detection report not found!"
        exit 1
      fi

      if [ "$(jq '.vulnerabilities | length' gl-secret-detection-report.json)" -gt 0 ]; then
        echo "Secrets detected in the codebase!"
        jq -r '.vulnerabilities[] | "- \(.message) in \(.location.file):\(.location.start_line)"' \
          gl-secret-detection-report.json
        exit 1
      else
        echo "No secrets detected"
      fi

check_sast:
  stage: quality
  image: apteno/alpine-jq:latest
  tags:
    - playground-bravo
  needs:
    - job: semgrep-sast
      artifacts: true
  script:
    - |
      if [ ! -f "gl-sast-report.json" ]; then
        echo "SAST report not found!"
        exit 1
      fi

      VULN_COUNT=$(jq '.vulnerabilities | length' gl-sast-report.json)
      if [ "$VULN_COUNT" -gt 0 ]; then
        echo "SAST vulnerabilities detected!"
        jq -r '.vulnerabilities[] | "- [\(.severity)] \(.name) in \(.location.file):\(.location.start_line)"' \
          gl-sast-report.json
        exit 1
      else
        echo "No SAST vulnerabilities detected"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_COMMIT_TAG
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

lint:
  stage: quality
  image: golangci/golangci-lint:v2.10-alpine
  tags:
    - playground-bravo
  extends: .go-cache
  cache:
    key:
      files:
        - go.sum
        - .golangci.yml
    paths:
      - .go/pkg/mod/
      - .go-cache/
      - .golangci-cache/
    policy: pull-push
  before_script:
    - export GOLANGCI_LINT_CACHE=${GOLANGCI_LINT_CACHE}
  script:
    - golangci-lint run --timeout=5m ./...

# === TEST STAGE ===

test:
  stage: test
  image: golang:1.26-alpine
  tags:
    - playground-bravo
  extends: .go-cache
  cache:
    key:
      files:
        - go.sum
    paths:
      - .go/pkg/mod/
      - .go-cache/
    policy: pull-push
  needs:
    - job: check_secrets
    - job: lint
    - job: check_sast
    - job: gosec
  services:
    - name: postgres:18-alpine
      alias: postgres
  variables:
    POSTGRES_USER: test
    POSTGRES_PASSWORD: test
    POSTGRES_DB: expense_bot_test
  before_script:
    - export TEST_DATABASE_URL="postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?sslmode=disable"
  script:
    # NOTE: Using -p 1 to avoid race conditions in database tests
    # Multiple packages connecting to same test DB causes migration conflicts
    - go test -v -coverprofile=coverage.out -covermode=atomic -p 1 ./...
    - go tool cover -func=coverage.out
    # Check coverage threshold using awk (bc not available in alpine)
    - |
      COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
      THRESHOLD=50
      echo "Coverage: ${COVERAGE}% (threshold: ${THRESHOLD}%)"
      if [ "$(awk "BEGIN {print ($COVERAGE < $THRESHOLD)}")" = "1" ]; then
        echo "Coverage ${COVERAGE}% is below threshold ${THRESHOLD}%!"
        exit 1
      fi
      echo "Coverage check passed!"
  artifacts:
    paths:
      - coverage.out
    expire_in: 1 week
  coverage: '/total:\s+\(statements\)\s+(\d+\.\d+)%/'


# === DEPLOY STAGE ===

deploy:
  stage: deploy
  image:
    name: alpine/git:latest
    entrypoint: [""]
  tags:
    - playground-bravo
  needs:
    - job: test
    - job: check_sast
    - job: lint
    - job: gosec
  before_script:
    # OPTIMIZED: Only install openssh-client (git already included)
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$DOKKU_SSH_PRIVATE_KEY_B64" | base64 -d > /tmp/deploy_key
    - chmod 600 /tmp/deploy_key
    - ssh-add /tmp/deploy_key
    - rm /tmp/deploy_key
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$DOKKU_HOST_KEY" >> ~/.ssh/known_hosts
  script:
    - git fetch --unshallow || true
    - git remote add dokku dokku@$DOKKU_HOST:expense-bot || true
    - git push dokku HEAD:refs/heads/master --force
  rules:
    - if: $CI_COMMIT_TAG =~ /^v.*/

# === RELEASE STAGE ===

release:
  stage: release
  image:
    name: goreleaser/goreleaser
    entrypoint: [""]
  tags:
    - playground-bravo
  needs:
    - job: test
    - job: check_sast
    - job: lint
    - job: gosec
  variables:
    GIT_DEPTH: 0
    GOTOOLCHAIN: auto
  script:
    - goreleaser release --config .goreleaser.gitlab.yaml --clean
  rules:
    - if: $CI_COMMIT_TAG =~ /^v.*/
