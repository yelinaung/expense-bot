
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bot: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">gitlab.com/yelinaung/expense-bot/internal/bot/bot.go (20.2%)</option>

				<option value="file1">gitlab.com/yelinaung/expense-bot/internal/bot/category_matcher.go (97.8%)</option>

				<option value="file2">gitlab.com/yelinaung/expense-bot/internal/bot/handlers.go (0.5%)</option>

				<option value="file3">gitlab.com/yelinaung/expense-bot/internal/bot/parser.go (98.6%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">// Package bot provides the Telegram bot initialization and handlers.
package bot

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "sync"
        "time"

        "github.com/go-telegram/bot"
        tgmodels "github.com/go-telegram/bot/models"
        "github.com/jackc/pgx/v5/pgxpool"
        "gitlab.com/yelinaung/expense-bot/internal/config"
        "gitlab.com/yelinaung/expense-bot/internal/gemini"
        "gitlab.com/yelinaung/expense-bot/internal/logger"
        "gitlab.com/yelinaung/expense-bot/internal/models"
        "gitlab.com/yelinaung/expense-bot/internal/repository"
)

// pendingEdit represents a pending edit operation waiting for user input.
type pendingEdit struct {
        ExpenseID int
        EditType  string // "amount" or "category"
        MessageID int    // Message ID to edit after update.
}

// Bot wraps the Telegram bot with application dependencies.
type Bot struct {
        bot          *bot.Bot
        cfg          *config.Config
        userRepo     *repository.UserRepository
        categoryRepo *repository.CategoryRepository
        expenseRepo  *repository.ExpenseRepository
        geminiClient *gemini.Client

        pendingEdits   map[int64]*pendingEdit // key is chatID
        pendingEditsMu sync.RWMutex
}

// New creates a new Bot instance.
func New(cfg *config.Config, pool *pgxpool.Pool) (*Bot, error) <span class="cov0" title="0">{
        b := &amp;Bot{
                cfg:          cfg,
                userRepo:     repository.NewUserRepository(pool),
                categoryRepo: repository.NewCategoryRepository(pool),
                expenseRepo:  repository.NewExpenseRepository(pool),
                pendingEdits: make(map[int64]*pendingEdit),
        }

        if cfg.GeminiAPIKey != "" </span><span class="cov0" title="0">{
                geminiClient, err := gemini.NewClient(context.Background(), cfg.GeminiAPIKey)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Warn().Err(err).Msg("Failed to create Gemini client, receipt OCR disabled")
                }</span> else<span class="cov0" title="0"> {
                        b.geminiClient = geminiClient
                        logger.Log.Info().Msg("Gemini client initialized for receipt OCR")
                }</span>
        }

        <span class="cov0" title="0">opts := []bot.Option{
                bot.WithMiddlewares(b.whitelistMiddleware),
                bot.WithDefaultHandler(b.defaultHandler),
        }

        telegramBot, err := bot.New(cfg.TelegramBotToken, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create bot: %w", err)
        }</span>

        <span class="cov0" title="0">b.bot = telegramBot
        b.registerHandlers()

        return b, nil</span>
}

const (
        // DraftExpirationTimeout is the duration after which draft expenses are deleted.
        DraftExpirationTimeout = 10 * time.Minute
        // DraftCleanupInterval is how often the cleanup goroutine runs.
        DraftCleanupInterval = 5 * time.Minute
)

// Start begins polling for updates.
func (b *Bot) Start(ctx context.Context) <span class="cov0" title="0">{
        b.cleanupExpiredDrafts(ctx)

        go b.startDraftCleanupLoop(ctx)

        logger.Log.Info().Msg("Bot started polling")
        b.bot.Start(ctx)
}</span>

// cleanupExpiredDrafts removes draft expenses older than DraftExpirationTimeout.
func (b *Bot) cleanupExpiredDrafts(ctx context.Context) <span class="cov0" title="0">{
        count, err := b.expenseRepo.DeleteExpiredDrafts(ctx, DraftExpirationTimeout)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to cleanup expired drafts")
                return
        }</span>
        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                logger.Log.Info().Int("count", count).Msg("Cleaned up expired draft expenses")
        }</span>
}

// startDraftCleanupLoop runs periodic cleanup of expired draft expenses.
func (b *Bot) startDraftCleanupLoop(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(DraftCleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Log.Info().Msg("Draft cleanup loop stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        b.cleanupExpiredDrafts(ctx)</span>
                }
        }
}

// registerHandlers sets up command handlers.
func (b *Bot) registerHandlers() <span class="cov0" title="0">{
        b.bot.RegisterHandler(bot.HandlerTypeMessageText, "/start", bot.MatchTypePrefix, b.handleStart)
        b.bot.RegisterHandler(bot.HandlerTypeMessageText, "/help", bot.MatchTypePrefix, b.handleHelp)
        b.bot.RegisterHandler(bot.HandlerTypeMessageText, "/categories", bot.MatchTypePrefix, b.handleCategories)
        b.bot.RegisterHandler(bot.HandlerTypeMessageText, "/add", bot.MatchTypePrefix, b.handleAdd)
        b.bot.RegisterHandler(bot.HandlerTypeMessageText, "/list", bot.MatchTypePrefix, b.handleList)
        b.bot.RegisterHandler(bot.HandlerTypeMessageText, "/today", bot.MatchTypePrefix, b.handleToday)
        b.bot.RegisterHandler(bot.HandlerTypeMessageText, "/week", bot.MatchTypePrefix, b.handleWeek)
        b.bot.RegisterHandler(bot.HandlerTypeMessageText, "/edit", bot.MatchTypePrefix, b.handleEdit)
        b.bot.RegisterHandler(bot.HandlerTypeMessageText, "/delete", bot.MatchTypePrefix, b.handleDelete)

        // Callback query handlers for receipt confirmation flow.
        b.bot.RegisterHandler(bot.HandlerTypeCallbackQueryData, "receipt_", bot.MatchTypePrefix, b.handleReceiptCallback)
        b.bot.RegisterHandler(bot.HandlerTypeCallbackQueryData, "edit_", bot.MatchTypePrefix, b.handleEditCallback)
        b.bot.RegisterHandler(bot.HandlerTypeCallbackQueryData, "set_category_", bot.MatchTypePrefix, b.handleSetCategoryCallback)
        b.bot.RegisterHandler(bot.HandlerTypeCallbackQueryData, "cancel_edit_", bot.MatchTypePrefix, b.handleCancelEditCallback)
        b.bot.RegisterHandler(bot.HandlerTypeCallbackQueryData, "create_category_", bot.MatchTypePrefix, b.handleCreateCategoryCallback)
}</span>

// whitelistMiddleware checks if the user is whitelisted before processing.
func (b *Bot) whitelistMiddleware(next bot.HandlerFunc) bot.HandlerFunc <span class="cov0" title="0">{
        return func(ctx context.Context, tgBot *bot.Bot, update *tgmodels.Update) </span><span class="cov0" title="0">{
                userID := extractUserID(update)
                if userID == 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">username := extractUsername(update)
                logUserAction(userID, username, update)

                if !b.cfg.IsUserWhitelisted(userID) </span><span class="cov0" title="0">{
                        logger.Log.Warn().
                                Int64("user_id", userID).
                                Str("username", username).
                                Msg("Blocked non-whitelisted user")
                        if update.Message != nil </span><span class="cov0" title="0">{
                                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                                        ChatID: update.Message.Chat.ID,
                                        Text:   "‚õî Sorry, you are not authorized to use this bot.",
                                })
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">if err := b.ensureUserRegistered(ctx, update); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error().
                                Int64("user_id", userID).
                                Err(err).
                                Msg("Failed to register user")
                }</span>

                <span class="cov0" title="0">next(ctx, tgBot, update)</span>
        }
}

// logUserAction logs the user's input/action.
func logUserAction(userID int64, username string, update *tgmodels.Update) <span class="cov8" title="1">{
        switch </span>{
        case update.Message != nil:<span class="cov8" title="1">
                msg := update.Message
                event := logger.Log.Info().
                        Int64("user_id", userID).
                        Str("username", username).
                        Int64("chat_id", msg.Chat.ID)

                if msg.Text != "" </span><span class="cov8" title="1">{
                        event = event.Str("text", msg.Text)
                }</span>
                <span class="cov8" title="1">if len(msg.Photo) &gt; 0 </span><span class="cov8" title="1">{
                        event = event.Str("type", "photo")
                }</span>
                <span class="cov8" title="1">if msg.Document != nil </span><span class="cov8" title="1">{
                        event = event.Str("type", "document").Str("filename", msg.Document.FileName)
                }</span>

                <span class="cov8" title="1">event.Msg("User input")</span>

        case update.CallbackQuery != nil:<span class="cov8" title="1">
                logger.Log.Info().
                        Int64("user_id", userID).
                        Str("username", username).
                        Str("data", update.CallbackQuery.Data).
                        Msg("Callback query")</span>

        case update.EditedMessage != nil:<span class="cov8" title="1">
                logger.Log.Info().
                        Int64("user_id", userID).
                        Str("username", username).
                        Str("text", update.EditedMessage.Text).
                        Msg("Edited message")</span>
        }
}

// extractUsername gets the username from the update.
func extractUsername(update *tgmodels.Update) string <span class="cov8" title="1">{
        if update.Message != nil &amp;&amp; update.Message.From != nil </span><span class="cov8" title="1">{
                return update.Message.From.Username
        }</span>
        <span class="cov8" title="1">if update.CallbackQuery != nil </span><span class="cov8" title="1">{
                return update.CallbackQuery.From.Username
        }</span>
        <span class="cov8" title="1">if update.EditedMessage != nil &amp;&amp; update.EditedMessage.From != nil </span><span class="cov8" title="1">{
                return update.EditedMessage.From.Username
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// ensureUserRegistered creates or updates the user record.
func (b *Bot) ensureUserRegistered(ctx context.Context, update *tgmodels.Update) error <span class="cov0" title="0">{
        var user *models.User

        if update.Message != nil &amp;&amp; update.Message.From != nil </span><span class="cov0" title="0">{
                from := update.Message.From
                user = &amp;models.User{
                        ID:        from.ID,
                        Username:  from.Username,
                        FirstName: from.FirstName,
                        LastName:  from.LastName,
                }
        }</span> else<span class="cov0" title="0"> if update.CallbackQuery != nil </span><span class="cov0" title="0">{
                from := update.CallbackQuery.From
                user = &amp;models.User{
                        ID:        from.ID,
                        Username:  from.Username,
                        FirstName: from.FirstName,
                        LastName:  from.LastName,
                }
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := b.userRepo.UpsertUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upsert user: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// extractUserID gets the user ID from various update types.
func extractUserID(update *tgmodels.Update) int64 <span class="cov8" title="1">{
        if update.Message != nil &amp;&amp; update.Message.From != nil </span><span class="cov8" title="1">{
                return update.Message.From.ID
        }</span>
        <span class="cov8" title="1">if update.CallbackQuery != nil </span><span class="cov8" title="1">{
                return update.CallbackQuery.From.ID
        }</span>
        <span class="cov8" title="1">if update.EditedMessage != nil &amp;&amp; update.EditedMessage.From != nil </span><span class="cov8" title="1">{
                return update.EditedMessage.From.ID
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// defaultHandler handles unrecognized messages, attempting free-text expense parsing.
func (b *Bot) defaultHandler(ctx context.Context, tgBot *bot.Bot, update *tgmodels.Update) <span class="cov0" title="0">{
        if update.Message == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chatID := update.Message.Chat.ID

        logger.Log.Debug().
                Int64("chat_id", chatID).
                Str("text", update.Message.Text).
                Msg("Default handler triggered")

        if len(update.Message.Photo) &gt; 0 </span><span class="cov0" title="0">{
                b.handlePhoto(ctx, tgBot, update)
                return
        }</span>

        // Check for pending edit operations first.
        <span class="cov0" title="0">if b.handlePendingEdit(ctx, tgBot, update) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if b.handleFreeTextExpense(ctx, tgBot, update) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">_, err := tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                ChatID:    chatID,
                Text:      "I didn't understand that. Use /help to see available commands, or send an expense like &lt;code&gt;5.50 Coffee&lt;/code&gt;",
                ParseMode: tgmodels.ParseModeHTML,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to send default response")
        }</span>
}

// downloadPhoto downloads a photo from Telegram servers.
func (b *Bot) downloadPhoto(ctx context.Context, tgBot *bot.Bot, fileID string) ([]byte, error) <span class="cov0" title="0">{
        file, err := tgBot.GetFile(ctx, &amp;bot.GetFileParams{
                FileID: fileID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">downloadURL := tgBot.FileDownloadLink(file)

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, downloadURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create download request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to download file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("download failed with status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">data, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file data: %w", err)
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}
</pre>

		<pre class="file" id="file1" style="display: none">package bot

import (
        "strings"

        "gitlab.com/yelinaung/expense-bot/internal/models"
)

// MatchCategory finds the best matching category for a suggested category name.
// Matching strategy:
// 1. Exact match (case-insensitive)
// 2. Contains match (e.g., "dining" matches "Food - Dining Out")
// 3. No match -&gt; returns nil.
func MatchCategory(suggested string, categories []models.Category) *models.Category <span class="cov8" title="1">{
        if suggested == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">suggestedLower := strings.ToLower(strings.TrimSpace(suggested))
        if suggestedLower == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Strategy 1: Exact match (case-insensitive).
        <span class="cov8" title="1">for i := range categories </span><span class="cov8" title="1">{
                if strings.EqualFold(categories[i].Name, suggested) </span><span class="cov8" title="1">{
                        return &amp;categories[i]
                }</span>
        }

        // Strategy 2: Contains match - find categories where suggested is a substring.
        // Track the best match (shortest category name that contains the term).
        <span class="cov8" title="1">var bestMatch *models.Category
        bestLen := 0

        for i := range categories </span><span class="cov8" title="1">{
                catLower := strings.ToLower(categories[i].Name)
                if strings.Contains(catLower, suggestedLower) </span><span class="cov8" title="1">{
                        if bestMatch == nil || len(categories[i].Name) &lt; bestLen </span><span class="cov8" title="1">{
                                bestMatch = &amp;categories[i]
                                bestLen = len(categories[i].Name)
                        }</span>
                }
        }

        <span class="cov8" title="1">if bestMatch != nil </span><span class="cov8" title="1">{
                return bestMatch
        }</span>

        // Strategy 2b: Check if category name contains suggested (reverse check).
        // e.g., suggested "Food - Dining Out" matches category "Dining Out".
        <span class="cov8" title="1">for i := range categories </span><span class="cov8" title="1">{
                catLower := strings.ToLower(categories[i].Name)
                if strings.Contains(suggestedLower, catLower) </span><span class="cov8" title="1">{
                        if bestMatch == nil || len(categories[i].Name) &gt; bestLen </span><span class="cov8" title="1">{
                                bestMatch = &amp;categories[i]
                                bestLen = len(categories[i].Name)
                        }</span>
                }
        }

        <span class="cov8" title="1">if bestMatch != nil </span><span class="cov8" title="1">{
                return bestMatch
        }</span>

        // Strategy 3: Word-based matching - check if any significant word matches.
        <span class="cov8" title="1">suggestedWords := extractSignificantWords(suggested)
        for i := range categories </span><span class="cov8" title="1">{
                catWords := extractSignificantWords(categories[i].Name)
                for _, sw := range suggestedWords </span><span class="cov8" title="1">{
                        for _, cw := range catWords </span><span class="cov8" title="1">{
                                if strings.EqualFold(sw, cw) </span><span class="cov0" title="0">{
                                        return &amp;categories[i]
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// extractSignificantWords extracts words from a string, filtering out common separators.
func extractSignificantWords(s string) []string <span class="cov8" title="1">{
        s = strings.ToLower(s)
        s = strings.ReplaceAll(s, "-", " ")
        s = strings.ReplaceAll(s, "/", " ")
        s = strings.ReplaceAll(s, "&amp;", " ")

        words := strings.Fields(s)
        var significant []string

        for _, w := range words </span><span class="cov8" title="1">{
                if len(w) &gt;= 3 &amp;&amp; !isStopWord(w) </span><span class="cov8" title="1">{
                        significant = append(significant, w)
                }</span>
        }

        <span class="cov8" title="1">return significant</span>
}

// isStopWord returns true for common words that shouldn't be matched.
func isStopWord(word string) bool <span class="cov8" title="1">{
        stopWords := map[string]bool{
                "and": true,
                "the": true,
                "for": true,
        }
        return stopWords[word]
}</span>
</pre>

		<pre class="file" id="file2" style="display: none">package bot

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/go-telegram/bot"
        "github.com/go-telegram/bot/models"
        "gitlab.com/yelinaung/expense-bot/internal/gemini"
        appmodels "gitlab.com/yelinaung/expense-bot/internal/models"

        "gitlab.com/yelinaung/expense-bot/internal/logger"
)

const categoryUncategorized = "Uncategorized"

// handleStart handles the /start command.
func (b *Bot) handleStart(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.Message == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">firstName := ""
        if update.Message.From != nil </span><span class="cov0" title="0">{
                firstName = update.Message.From.FirstName
        }</span>

        <span class="cov0" title="0">text := fmt.Sprintf(`üëã Welcome%s!

I'm your personal expense tracker bot. I help you track your daily expenses in SGD.

&lt;b&gt;Quick Start:&lt;/b&gt;
‚Ä¢ Send an expense like: &lt;code&gt;5.50 Coffee&lt;/code&gt;
‚Ä¢ Or use structured format: &lt;code&gt;/add 5.50 Coffee Food - Dining Out&lt;/code&gt;

Use /help to see all available commands.`,
                formatGreeting(firstName))

        logger.Log.Debug().Int64("chat_id", update.Message.Chat.ID).Msg("Sending /start response")
        _, err := tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                ChatID:    update.Message.Chat.ID,
                Text:      text,
                ParseMode: models.ParseModeHTML,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to send /start response")
        }</span>
}

// handleHelp handles the /help command.
func (b *Bot) handleHelp(_ context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.Message == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">text := `üìö &lt;b&gt;Available Commands&lt;/b&gt;

&lt;b&gt;Expense Tracking:&lt;/b&gt;
‚Ä¢ &lt;code&gt;/add &amp;lt;amount&amp;gt; &amp;lt;description&amp;gt; [category]&lt;/code&gt; - Add an expense
‚Ä¢ Just send a message like &lt;code&gt;5.50 Coffee&lt;/code&gt; to quickly add

&lt;b&gt;Viewing Expenses:&lt;/b&gt;
‚Ä¢ &lt;code&gt;/list&lt;/code&gt; - Show recent expenses
‚Ä¢ &lt;code&gt;/today&lt;/code&gt; - Show today's expenses
‚Ä¢ &lt;code&gt;/week&lt;/code&gt; - Show this week's expenses

&lt;b&gt;Categories:&lt;/b&gt;
‚Ä¢ &lt;code&gt;/categories&lt;/code&gt; - List all categories

&lt;b&gt;Other:&lt;/b&gt;
‚Ä¢ &lt;code&gt;/help&lt;/code&gt; - Show this help message`

        logger.Log.Debug().Int64("chat_id", update.Message.Chat.ID).Msg("Sending /help response")
        _, err := tgBot.SendMessage(context.Background(), &amp;bot.SendMessageParams{
                ChatID:    update.Message.Chat.ID,
                Text:      text,
                ParseMode: models.ParseModeHTML,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to send /help response")
        }</span>
}

// handleCategories handles the /categories command.
func (b *Bot) handleCategories(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.Message == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">categories, err := b.categoryRepo.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: update.Message.Chat.ID,
                        Text:   "‚ùå Failed to fetch categories. Please try again.",
                })
                return
        }</span>

        <span class="cov0" title="0">if len(categories) == 0 </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: update.Message.Chat.ID,
                        Text:   "No categories found.",
                })
                return
        }</span>

        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString("üìÅ &lt;b&gt;Expense Categories&lt;/b&gt;\n\n")
        for i, cat := range categories </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("%d. %s\n", i+1, cat.Name))
        }</span>

        <span class="cov0" title="0">logger.Log.Debug().Int64("chat_id", update.Message.Chat.ID).Msg("Sending /categories response")
        _, err = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                ChatID:    update.Message.Chat.ID,
                Text:      sb.String(),
                ParseMode: models.ParseModeHTML,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to send /categories response")
        }</span>
}

// formatGreeting returns a greeting suffix with the user's name.
func formatGreeting(firstName string) string <span class="cov8" title="1">{
        if firstName == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return ", " + firstName</span>
}

// handleAdd handles the /add command for structured expense input.
func (b *Bot) handleAdd(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.Message == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chatID := update.Message.Chat.ID
        userID := update.Message.From.ID

        categories, err := b.categoryRepo.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to fetch categories for parsing")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Failed to process expense. Please try again.",
                })
                return
        }</span>

        <span class="cov0" title="0">categoryNames := make([]string, len(categories))
        for i, cat := range categories </span><span class="cov0" title="0">{
                categoryNames[i] = cat.Name
        }</span>

        <span class="cov0" title="0">parsed := ParseAddCommandWithCategories(update.Message.Text, categoryNames)
        if parsed == nil </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID:    chatID,
                        Text:      "‚ùå Invalid format. Use: &lt;code&gt;/add 5.50 Coffee [category]&lt;/code&gt;",
                        ParseMode: models.ParseModeHTML,
                })
                return
        }</span>

        <span class="cov0" title="0">b.saveExpense(ctx, tgBot, chatID, userID, parsed, categories)</span>
}

// handleFreeTextExpense handles free-text expense input like "5.50 Coffee".
func (b *Bot) handleFreeTextExpense(ctx context.Context, tgBot *bot.Bot, update *models.Update) bool <span class="cov0" title="0">{
        if update.Message == nil || update.Message.Text == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">text := update.Message.Text
        if strings.HasPrefix(text, "/") </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">categories, err := b.categoryRepo.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to fetch categories for free-text parsing")
                return false
        }</span>

        <span class="cov0" title="0">categoryNames := make([]string, len(categories))
        for i, cat := range categories </span><span class="cov0" title="0">{
                categoryNames[i] = cat.Name
        }</span>

        <span class="cov0" title="0">parsed := ParseExpenseInputWithCategories(text, categoryNames)
        if parsed == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">chatID := update.Message.Chat.ID
        userID := update.Message.From.ID

        b.saveExpense(ctx, tgBot, chatID, userID, parsed, categories)
        return true</span>
}

// saveExpense creates and saves an expense to the database.
func (b *Bot) saveExpense(
        ctx context.Context,
        tgBot *bot.Bot,
        chatID int64,
        userID int64,
        parsed *ParsedExpense,
        categories []appmodels.Category,
) <span class="cov0" title="0">{
        expense := &amp;appmodels.Expense{
                UserID:      userID,
                Amount:      parsed.Amount,
                Currency:    "SGD",
                Description: parsed.Description,
        }

        if parsed.CategoryName != "" </span><span class="cov0" title="0">{
                for _, cat := range categories </span><span class="cov0" title="0">{
                        if strings.EqualFold(cat.Name, parsed.CategoryName) </span><span class="cov0" title="0">{
                                expense.CategoryID = &amp;cat.ID
                                expense.Category = &amp;cat
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if err := b.expenseRepo.Create(ctx, expense); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to create expense")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Failed to save expense. Please try again.",
                })
                return
        }</span>

        <span class="cov0" title="0">logger.Log.Debug().
                Int64("chat_id", chatID).
                Int64("user_id", userID).
                Str("amount", expense.Amount.String()).
                Str("description", expense.Description).
                Msg("Expense created")

        categoryText := categoryUncategorized
        if expense.Category != nil </span><span class="cov0" title="0">{
                categoryText = expense.Category.Name
        }</span>

        <span class="cov0" title="0">descText := ""
        if expense.Description != "" </span><span class="cov0" title="0">{
                descText = fmt.Sprintf("\nüìù %s", expense.Description)
        }</span>

        <span class="cov0" title="0">text := fmt.Sprintf(`‚úÖ &lt;b&gt;Expense Added&lt;/b&gt;

üí∞ $%s SGD%s
üìÅ %s
üÜî #%d`,
                expense.Amount.StringFixed(2),
                descText,
                categoryText,
                expense.ID)

        _, err := tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                ChatID:    chatID,
                Text:      text,
                ParseMode: models.ParseModeHTML,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to send expense confirmation")
        }</span>
}

// handleList handles the /list command to show recent expenses.
func (b *Bot) handleList(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.Message == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chatID := update.Message.Chat.ID
        userID := update.Message.From.ID

        expenses, err := b.expenseRepo.GetByUserID(ctx, userID, 10)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to fetch expenses")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Failed to fetch expenses. Please try again.",
                })
                return
        }</span>

        <span class="cov0" title="0">b.sendExpenseList(ctx, tgBot, chatID, expenses, "üìã &lt;b&gt;Recent Expenses&lt;/b&gt;")</span>
}

// handleToday handles the /today command to show today's expenses.
func (b *Bot) handleToday(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.Message == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chatID := update.Message.Chat.ID
        userID := update.Message.From.ID

        now := time.Now()
        startOfDay := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())
        endOfDay := startOfDay.Add(24 * time.Hour)

        expenses, err := b.expenseRepo.GetByUserIDAndDateRange(ctx, userID, startOfDay, endOfDay)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to fetch today's expenses")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Failed to fetch expenses. Please try again.",
                })
                return
        }</span>

        <span class="cov0" title="0">total, _ := b.expenseRepo.GetTotalByUserIDAndDateRange(ctx, userID, startOfDay, endOfDay)
        header := fmt.Sprintf("üìÖ &lt;b&gt;Today's Expenses&lt;/b&gt; (Total: $%s)", total.StringFixed(2))
        b.sendExpenseList(ctx, tgBot, chatID, expenses, header)</span>
}

// handleWeek handles the /week command to show this week's expenses.
func (b *Bot) handleWeek(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.Message == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chatID := update.Message.Chat.ID
        userID := update.Message.From.ID

        now := time.Now()
        weekday := int(now.Weekday())
        if weekday == 0 </span><span class="cov0" title="0">{
                weekday = 7
        }</span>
        <span class="cov0" title="0">startOfWeek := time.Date(now.Year(), now.Month(), now.Day()-weekday+1, 0, 0, 0, 0, now.Location())
        endOfWeek := startOfWeek.Add(7 * 24 * time.Hour)

        expenses, err := b.expenseRepo.GetByUserIDAndDateRange(ctx, userID, startOfWeek, endOfWeek)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to fetch week's expenses")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Failed to fetch expenses. Please try again.",
                })
                return
        }</span>

        <span class="cov0" title="0">total, _ := b.expenseRepo.GetTotalByUserIDAndDateRange(ctx, userID, startOfWeek, endOfWeek)
        header := fmt.Sprintf("üìÜ &lt;b&gt;This Week's Expenses&lt;/b&gt; (Total: $%s)", total.StringFixed(2))
        b.sendExpenseList(ctx, tgBot, chatID, expenses, header)</span>
}

// sendExpenseList formats and sends a list of expenses.
func (b *Bot) sendExpenseList(
        ctx context.Context,
        tgBot *bot.Bot,
        chatID int64,
        expenses []appmodels.Expense,
        header string,
) <span class="cov0" title="0">{
        if len(expenses) == 0 </span><span class="cov0" title="0">{
                _, err := tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID:    chatID,
                        Text:      header + "\n\nNo expenses found.",
                        ParseMode: models.ParseModeHTML,
                })
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error().Err(err).Msg("Failed to send empty expense list")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString(header)
        sb.WriteString("\n\n")

        for _, exp := range expenses </span><span class="cov0" title="0">{
                categoryText := ""
                if exp.Category != nil </span><span class="cov0" title="0">{
                        categoryText = fmt.Sprintf(" [%s]", exp.Category.Name)
                }</span>

                <span class="cov0" title="0">descText := ""
                if exp.Description != "" </span><span class="cov0" title="0">{
                        descText = " - " + exp.Description
                }</span>

                <span class="cov0" title="0">sb.WriteString(fmt.Sprintf(
                        "#%d $%s%s%s\n&lt;i&gt;%s&lt;/i&gt;\n\n",
                        exp.ID,
                        exp.Amount.StringFixed(2),
                        descText,
                        categoryText,
                        exp.CreatedAt.Format("Jan 2 15:04"),
                ))</span>
        }

        <span class="cov0" title="0">logger.Log.Debug().Int64("chat_id", chatID).Int("count", len(expenses)).Msg("Sending expense list")
        _, err := tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                ChatID:    chatID,
                Text:      sb.String(),
                ParseMode: models.ParseModeHTML,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to send expense list")
        }</span>
}

// handleEdit handles the /edit command to modify an expense.
func (b *Bot) handleEdit(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.Message == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chatID := update.Message.Chat.ID
        userID := update.Message.From.ID

        args := strings.TrimPrefix(update.Message.Text, "/edit")
        args = strings.TrimSpace(args)

        if idx := strings.Index(args, "@"); idx == 0 </span><span class="cov0" title="0">{
                if spaceIdx := strings.Index(args, " "); spaceIdx != -1 </span><span class="cov0" title="0">{
                        args = strings.TrimSpace(args[spaceIdx:])
                }</span> else<span class="cov0" title="0"> {
                        args = ""
                }</span>
        }

        <span class="cov0" title="0">if args == "" </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID:    chatID,
                        Text:      "‚ùå Usage: &lt;code&gt;/edit &amp;lt;id&amp;gt; &amp;lt;amount&amp;gt; &amp;lt;description&amp;gt; [category]&lt;/code&gt;",
                        ParseMode: models.ParseModeHTML,
                })
                return
        }</span>

        <span class="cov0" title="0">parts := strings.SplitN(args, " ", 2)
        expenseID, err := strconv.Atoi(parts[0])
        if err != nil </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID:    chatID,
                        Text:      "‚ùå Invalid expense ID. Use: &lt;code&gt;/edit &amp;lt;id&amp;gt; &amp;lt;amount&amp;gt; &amp;lt;description&amp;gt;&lt;/code&gt;",
                        ParseMode: models.ParseModeHTML,
                })
                return
        }</span>

        <span class="cov0" title="0">expense, err := b.expenseRepo.GetByID(ctx, expenseID)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   fmt.Sprintf("‚ùå Expense #%d not found.", expenseID),
                })
                return
        }</span>

        <span class="cov0" title="0">if expense.UserID != userID </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå You can only edit your own expenses.",
                })
                return
        }</span>

        <span class="cov0" title="0">if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID:    chatID,
                        Text:      "‚ùå Please provide new values: &lt;code&gt;/edit &amp;lt;id&amp;gt; &amp;lt;amount&amp;gt; &amp;lt;description&amp;gt;&lt;/code&gt;",
                        ParseMode: models.ParseModeHTML,
                })
                return
        }</span>

        <span class="cov0" title="0">categories, _ := b.categoryRepo.GetAll(ctx)
        categoryNames := make([]string, len(categories))
        for i, cat := range categories </span><span class="cov0" title="0">{
                categoryNames[i] = cat.Name
        }</span>

        <span class="cov0" title="0">parsed := ParseExpenseInputWithCategories(parts[1], categoryNames)
        if parsed == nil </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID:    chatID,
                        Text:      "‚ùå Invalid format. Use: &lt;code&gt;/edit &amp;lt;id&amp;gt; &amp;lt;amount&amp;gt; &amp;lt;description&amp;gt;&lt;/code&gt;",
                        ParseMode: models.ParseModeHTML,
                })
                return
        }</span>

        <span class="cov0" title="0">expense.Amount = parsed.Amount
        expense.Description = parsed.Description

        if parsed.CategoryName != "" </span><span class="cov0" title="0">{
                for _, cat := range categories </span><span class="cov0" title="0">{
                        if strings.EqualFold(cat.Name, parsed.CategoryName) </span><span class="cov0" title="0">{
                                expense.CategoryID = &amp;cat.ID
                                expense.Category = &amp;cat
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if err := b.expenseRepo.Update(ctx, expense); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Int("expense_id", expenseID).Msg("Failed to update expense")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Failed to update expense. Please try again.",
                })
                return
        }</span>

        <span class="cov0" title="0">logger.Log.Debug().
                Int64("chat_id", chatID).
                Int("expense_id", expenseID).
                Msg("Expense updated")

        categoryText := categoryUncategorized
        if expense.Category != nil </span><span class="cov0" title="0">{
                categoryText = expense.Category.Name
        }</span>

        <span class="cov0" title="0">text := fmt.Sprintf(`‚úÖ &lt;b&gt;Expense Updated&lt;/b&gt;

üÜî #%d
üí∞ $%s SGD
üìù %s
üìÅ %s`,
                expense.ID,
                expense.Amount.StringFixed(2),
                expense.Description,
                categoryText)

        _, err = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                ChatID:    chatID,
                Text:      text,
                ParseMode: models.ParseModeHTML,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to send edit confirmation")
        }</span>
}

// handleDelete handles the /delete command to remove an expense.
func (b *Bot) handleDelete(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.Message == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chatID := update.Message.Chat.ID
        userID := update.Message.From.ID

        args := strings.TrimPrefix(update.Message.Text, "/delete")
        args = strings.TrimSpace(args)

        if idx := strings.Index(args, "@"); idx == 0 </span><span class="cov0" title="0">{
                if spaceIdx := strings.Index(args, " "); spaceIdx != -1 </span><span class="cov0" title="0">{
                        args = strings.TrimSpace(args[spaceIdx:])
                }</span> else<span class="cov0" title="0"> {
                        args = ""
                }</span>
        }

        <span class="cov0" title="0">if args == "" </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID:    chatID,
                        Text:      "‚ùå Usage: &lt;code&gt;/delete &amp;lt;id&amp;gt;&lt;/code&gt;",
                        ParseMode: models.ParseModeHTML,
                })
                return
        }</span>

        <span class="cov0" title="0">expenseID, err := strconv.Atoi(args)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID:    chatID,
                        Text:      "‚ùå Invalid expense ID. Use: &lt;code&gt;/delete &amp;lt;id&amp;gt;&lt;/code&gt;",
                        ParseMode: models.ParseModeHTML,
                })
                return
        }</span>

        <span class="cov0" title="0">expense, err := b.expenseRepo.GetByID(ctx, expenseID)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   fmt.Sprintf("‚ùå Expense #%d not found.", expenseID),
                })
                return
        }</span>

        <span class="cov0" title="0">if expense.UserID != userID </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå You can only delete your own expenses.",
                })
                return
        }</span>

        <span class="cov0" title="0">if err := b.expenseRepo.Delete(ctx, expenseID); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Int("expense_id", expenseID).Msg("Failed to delete expense")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Failed to delete expense. Please try again.",
                })
                return
        }</span>

        <span class="cov0" title="0">logger.Log.Debug().
                Int64("chat_id", chatID).
                Int("expense_id", expenseID).
                Msg("Expense deleted")

        text := fmt.Sprintf("‚úÖ Expense #%d deleted.", expenseID)
        _, err = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                ChatID: chatID,
                Text:   text,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to send delete confirmation")
        }</span>
}

// handlePhoto handles photo messages for receipt OCR.
func (b *Bot) handlePhoto(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.Message == nil || len(update.Message.Photo) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chatID := update.Message.Chat.ID
        userID := update.Message.From.ID

        logger.Log.Info().
                Int64("chat_id", chatID).
                Int64("user_id", userID).
                Int("photo_count", len(update.Message.Photo)).
                Msg("Received photo message")

        if b.geminiClient == nil </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID:    chatID,
                        Text:      "üì∑ Receipt OCR is not configured. Please add expenses manually using /add or send text like &lt;code&gt;5.50 Coffee&lt;/code&gt;",
                        ParseMode: models.ParseModeHTML,
                })
                return
        }</span>

        <span class="cov0" title="0">largestPhoto := update.Message.Photo[len(update.Message.Photo)-1]

        logger.Log.Debug().
                Int64("chat_id", chatID).
                Int64("user_id", userID).
                Str("file_id", largestPhoto.FileID).
                Int("width", largestPhoto.Width).
                Int("height", largestPhoto.Height).
                Msg("Downloading photo")

        _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                ChatID: chatID,
                Text:   "üì∑ Processing receipt...",
        })

        imageBytes, err := b.downloadPhoto(ctx, tgBot, largestPhoto.FileID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).
                        Int64("chat_id", chatID).
                        Int64("user_id", userID).
                        Msg("Failed to download photo")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Failed to download photo. Please try again.",
                })
                return
        }</span>

        <span class="cov0" title="0">logger.Log.Info().
                Int64("chat_id", chatID).
                Int64("user_id", userID).
                Int("size_bytes", len(imageBytes)).
                Msg("Photo downloaded successfully")

        receiptData, err := b.geminiClient.ParseReceipt(ctx, imageBytes, "image/jpeg")
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).
                        Int64("chat_id", chatID).
                        Int64("user_id", userID).
                        Msg("Failed to parse receipt")

                switch </span>{
                case errors.Is(err, gemini.ErrParseTimeout):<span class="cov0" title="0">
                        _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                                ChatID:    chatID,
                                Text:      "‚è±Ô∏è Receipt processing timed out. Please try again or add manually: &lt;code&gt;/add &amp;lt;amount&amp;gt; &amp;lt;description&amp;gt;&lt;/code&gt;",
                                ParseMode: models.ParseModeHTML,
                        })</span>
                case errors.Is(err, gemini.ErrNoData):<span class="cov0" title="0">
                        _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                                ChatID:    chatID,
                                Text:      "‚ùå Could not read this receipt. Please add manually: &lt;code&gt;/add &amp;lt;amount&amp;gt; &amp;lt;description&amp;gt;&lt;/code&gt;",
                                ParseMode: models.ParseModeHTML,
                        })</span>
                default:<span class="cov0" title="0">
                        _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                                ChatID:    chatID,
                                Text:      "‚ùå Could not read this receipt. Please add manually: &lt;code&gt;/add &amp;lt;amount&amp;gt; &amp;lt;description&amp;gt;&lt;/code&gt;",
                                ParseMode: models.ParseModeHTML,
                        })</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">isPartial := receiptData.IsPartial()

        logger.Log.Info().
                Int64("chat_id", chatID).
                Int64("user_id", userID).
                Str("amount", receiptData.Amount.String()).
                Str("merchant", receiptData.Merchant).
                Str("category", receiptData.SuggestedCategory).
                Float64("confidence", receiptData.Confidence).
                Bool("partial", isPartial).
                Msg("Receipt parsed")

        categories, _ := b.categoryRepo.GetAll(ctx)
        var categoryID *int
        var category *appmodels.Category
        for i := range categories </span><span class="cov0" title="0">{
                if strings.EqualFold(categories[i].Name, receiptData.SuggestedCategory) </span><span class="cov0" title="0">{
                        categoryID = &amp;categories[i].ID
                        category = &amp;categories[i]
                        break</span>
                }
        }

        // Use sensible defaults for partial data.
        <span class="cov0" title="0">description := receiptData.Merchant
        if description == "" </span><span class="cov0" title="0">{
                description = "Unknown merchant"
        }</span>

        <span class="cov0" title="0">expense := &amp;appmodels.Expense{
                UserID:        userID,
                Amount:        receiptData.Amount,
                Currency:      "SGD",
                Description:   description,
                CategoryID:    categoryID,
                Category:      category,
                ReceiptFileID: largestPhoto.FileID,
                Status:        appmodels.ExpenseStatusDraft,
        }

        if err := b.expenseRepo.Create(ctx, expense); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to create draft expense")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Failed to save expense. Please try again.",
                })
                return
        }</span>

        <span class="cov0" title="0">categoryText := categoryUncategorized
        if category != nil </span><span class="cov0" title="0">{
                categoryText = category.Name
        }</span>

        <span class="cov0" title="0">dateText := "Unknown"
        if !receiptData.Date.IsZero() </span><span class="cov0" title="0">{
                dateText = receiptData.Date.Format("02 Jan 2006")
        }</span>

        // Build message based on extraction completeness.
        <span class="cov0" title="0">var text string
        if isPartial </span><span class="cov0" title="0">{
                text = fmt.Sprintf(`‚ö†Ô∏è &lt;b&gt;Partial Extraction - Please Verify&lt;/b&gt;

üí∞ Amount: $%s SGD
üè™ Merchant: %s
üìÖ Date: %s
üìÅ Category: %s

&lt;i&gt;Some data could not be extracted. Please edit or confirm.&lt;/i&gt;`,
                        expense.Amount.StringFixed(2),
                        expense.Description,
                        dateText,
                        categoryText)
        }</span> else<span class="cov0" title="0"> {
                text = fmt.Sprintf(`üì∏ &lt;b&gt;Receipt Scanned!&lt;/b&gt;

üí∞ Amount: $%s SGD
üè™ Merchant: %s
üìÖ Date: %s
üìÅ Category: %s`,
                        expense.Amount.StringFixed(2),
                        expense.Description,
                        dateText,
                        categoryText)
        }</span>

        <span class="cov0" title="0">keyboard := &amp;models.InlineKeyboardMarkup{
                InlineKeyboard: [][]models.InlineKeyboardButton{
                        {
                                {Text: "‚úÖ Confirm", CallbackData: fmt.Sprintf("receipt_confirm_%d", expense.ID)},
                                {Text: "‚úèÔ∏è Edit", CallbackData: fmt.Sprintf("receipt_edit_%d", expense.ID)},
                                {Text: "‚ùå Cancel", CallbackData: fmt.Sprintf("receipt_cancel_%d", expense.ID)},
                        },
                },
        }

        msg, err := tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                ChatID:      chatID,
                Text:        text,
                ParseMode:   models.ParseModeHTML,
                ReplyMarkup: keyboard,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to send receipt confirmation")
                return
        }</span>

        <span class="cov0" title="0">logger.Log.Debug().
                Int64("chat_id", chatID).
                Int("expense_id", expense.ID).
                Int("message_id", msg.ID).
                Bool("partial", isPartial).
                Msg("Receipt confirmation sent with inline keyboard")</span>
}

// handleReceiptCallback handles receipt confirmation button presses.
func (b *Bot) handleReceiptCallback(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.CallbackQuery == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">data := update.CallbackQuery.Data
        userID := update.CallbackQuery.From.ID
        chatID := update.CallbackQuery.Message.Message.Chat.ID
        messageID := update.CallbackQuery.Message.Message.ID

        logger.Log.Debug().
                Str("callback_data", data).
                Int64("user_id", userID).
                Msg("Processing receipt callback")

        _, _ = tgBot.AnswerCallbackQuery(ctx, &amp;bot.AnswerCallbackQueryParams{
                CallbackQueryID: update.CallbackQuery.ID,
        })

        parts := strings.Split(data, "_")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                logger.Log.Error().Str("data", data).Msg("Invalid callback data format")
                return
        }</span>

        <span class="cov0" title="0">action := parts[1]
        expenseID, err := strconv.Atoi(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Str("data", data).Msg("Failed to parse expense ID")
                return
        }</span>

        <span class="cov0" title="0">expense, err := b.expenseRepo.GetByID(ctx, expenseID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Int("expense_id", expenseID).Msg("Expense not found")
                _, _ = tgBot.EditMessageText(ctx, &amp;bot.EditMessageTextParams{
                        ChatID:    chatID,
                        MessageID: messageID,
                        Text:      "‚ùå Expense not found.",
                })
                return
        }</span>

        <span class="cov0" title="0">if expense.UserID != userID </span><span class="cov0" title="0">{
                logger.Log.Warn().Int64("user_id", userID).Int("expense_id", expenseID).Msg("User mismatch")
                return
        }</span>

        <span class="cov0" title="0">switch action </span>{
        case "confirm":<span class="cov0" title="0">
                b.handleConfirmReceipt(ctx, tgBot, chatID, messageID, expense)</span>
        case "cancel":<span class="cov0" title="0">
                b.handleCancelReceipt(ctx, tgBot, chatID, messageID, expense)</span>
        case "edit":<span class="cov0" title="0">
                b.handleEditReceipt(ctx, tgBot, chatID, messageID, expense)</span>
        case "back":<span class="cov0" title="0">
                b.handleBackToReceipt(ctx, tgBot, chatID, messageID, expense)</span>
        }
}

// handleBackToReceipt returns to the main receipt confirmation view.
func (b *Bot) handleBackToReceipt(
        ctx context.Context,
        tgBot *bot.Bot,
        chatID int64,
        messageID int,
        expense *appmodels.Expense,
) <span class="cov0" title="0">{
        categoryText := categoryUncategorized
        if expense.Category != nil </span><span class="cov0" title="0">{
                categoryText = expense.Category.Name
        }</span> else<span class="cov0" title="0"> if expense.CategoryID != nil </span><span class="cov0" title="0">{
                cat, err := b.categoryRepo.GetByID(ctx, *expense.CategoryID)
                if err == nil </span><span class="cov0" title="0">{
                        categoryText = cat.Name
                }</span>
        }

        <span class="cov0" title="0">text := fmt.Sprintf(`üì∏ &lt;b&gt;Receipt Scanned!&lt;/b&gt;

üí∞ Amount: $%s SGD
üè™ Merchant: %s
üìÅ Category: %s`,
                expense.Amount.StringFixed(2),
                expense.Description,
                categoryText)

        keyboard := &amp;models.InlineKeyboardMarkup{
                InlineKeyboard: [][]models.InlineKeyboardButton{
                        {
                                {Text: "‚úÖ Confirm", CallbackData: fmt.Sprintf("receipt_confirm_%d", expense.ID)},
                                {Text: "‚úèÔ∏è Edit", CallbackData: fmt.Sprintf("receipt_edit_%d", expense.ID)},
                                {Text: "‚ùå Cancel", CallbackData: fmt.Sprintf("receipt_cancel_%d", expense.ID)},
                        },
                },
        }

        _, _ = tgBot.EditMessageText(ctx, &amp;bot.EditMessageTextParams{
                ChatID:      chatID,
                MessageID:   messageID,
                Text:        text,
                ParseMode:   models.ParseModeHTML,
                ReplyMarkup: keyboard,
        })</span>
}

// handleConfirmReceipt confirms a draft expense.
func (b *Bot) handleConfirmReceipt(
        ctx context.Context,
        tgBot *bot.Bot,
        chatID int64,
        messageID int,
        expense *appmodels.Expense,
) <span class="cov0" title="0">{
        expense.Status = appmodels.ExpenseStatusConfirmed
        if err := b.expenseRepo.Update(ctx, expense); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Int("expense_id", expense.ID).Msg("Failed to confirm expense")
                _, _ = tgBot.EditMessageText(ctx, &amp;bot.EditMessageTextParams{
                        ChatID:    chatID,
                        MessageID: messageID,
                        Text:      "‚ùå Failed to confirm expense. Please try again.",
                })
                return
        }</span>

        <span class="cov0" title="0">categoryText := categoryUncategorized
        if expense.Category != nil </span><span class="cov0" title="0">{
                categoryText = expense.Category.Name
        }</span> else<span class="cov0" title="0"> if expense.CategoryID != nil </span><span class="cov0" title="0">{
                cat, err := b.categoryRepo.GetByID(ctx, *expense.CategoryID)
                if err == nil </span><span class="cov0" title="0">{
                        categoryText = cat.Name
                }</span>
        }

        <span class="cov0" title="0">text := fmt.Sprintf(`‚úÖ &lt;b&gt;Expense Confirmed!&lt;/b&gt;

üí∞ Amount: $%s SGD
üè™ Description: %s
üìÅ Category: %s

Expense #%d has been saved.`,
                expense.Amount.StringFixed(2),
                expense.Description,
                categoryText,
                expense.ID)

        logger.Log.Info().
                Int("expense_id", expense.ID).
                Str("amount", expense.Amount.String()).
                Msg("Expense confirmed via callback")

        _, _ = tgBot.EditMessageText(ctx, &amp;bot.EditMessageTextParams{
                ChatID:    chatID,
                MessageID: messageID,
                Text:      text,
                ParseMode: models.ParseModeHTML,
        })</span>
}

// handleCancelReceipt cancels and deletes a draft expense.
func (b *Bot) handleCancelReceipt(
        ctx context.Context,
        tgBot *bot.Bot,
        chatID int64,
        messageID int,
        expense *appmodels.Expense,
) <span class="cov0" title="0">{
        if err := b.expenseRepo.Delete(ctx, expense.ID); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Int("expense_id", expense.ID).Msg("Failed to delete expense")
                _, _ = tgBot.EditMessageText(ctx, &amp;bot.EditMessageTextParams{
                        ChatID:    chatID,
                        MessageID: messageID,
                        Text:      "‚ùå Failed to cancel expense. Please try again.",
                })
                return
        }</span>

        <span class="cov0" title="0">logger.Log.Info().
                Int("expense_id", expense.ID).
                Msg("Expense cancelled via callback")

        _, _ = tgBot.EditMessageText(ctx, &amp;bot.EditMessageTextParams{
                ChatID:    chatID,
                MessageID: messageID,
                Text:      "üóëÔ∏è Receipt scan cancelled. The expense was not saved.",
        })</span>
}

// handleEditReceipt shows edit options for a draft expense.
func (b *Bot) handleEditReceipt(
        ctx context.Context,
        tgBot *bot.Bot,
        chatID int64,
        messageID int,
        expense *appmodels.Expense,
) <span class="cov0" title="0">{
        keyboard := &amp;models.InlineKeyboardMarkup{
                InlineKeyboard: [][]models.InlineKeyboardButton{
                        {
                                {Text: "üí∞ Edit Amount", CallbackData: fmt.Sprintf("edit_amount_%d", expense.ID)},
                                {Text: "üìÅ Edit Category", CallbackData: fmt.Sprintf("edit_category_%d", expense.ID)},
                        },
                        {
                                {Text: "‚¨ÖÔ∏è Back", CallbackData: fmt.Sprintf("receipt_back_%d", expense.ID)},
                        },
                },
        }

        categoryText := categoryUncategorized
        if expense.Category != nil </span><span class="cov0" title="0">{
                categoryText = expense.Category.Name
        }</span> else<span class="cov0" title="0"> if expense.CategoryID != nil </span><span class="cov0" title="0">{
                cat, err := b.categoryRepo.GetByID(ctx, *expense.CategoryID)
                if err == nil </span><span class="cov0" title="0">{
                        categoryText = cat.Name
                }</span>
        }

        <span class="cov0" title="0">text := fmt.Sprintf(`‚úèÔ∏è &lt;b&gt;Edit Expense&lt;/b&gt;

üí∞ Amount: $%s SGD
üè™ Description: %s
üìÅ Category: %s

Select what to edit:`,
                expense.Amount.StringFixed(2),
                expense.Description,
                categoryText)

        _, _ = tgBot.EditMessageText(ctx, &amp;bot.EditMessageTextParams{
                ChatID:      chatID,
                MessageID:   messageID,
                Text:        text,
                ParseMode:   models.ParseModeHTML,
                ReplyMarkup: keyboard,
        })</span>
}

// handleEditCallback handles edit sub-menu button presses.
func (b *Bot) handleEditCallback(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.CallbackQuery == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">data := update.CallbackQuery.Data
        userID := update.CallbackQuery.From.ID
        chatID := update.CallbackQuery.Message.Message.Chat.ID
        messageID := update.CallbackQuery.Message.Message.ID

        _, _ = tgBot.AnswerCallbackQuery(ctx, &amp;bot.AnswerCallbackQueryParams{
                CallbackQueryID: update.CallbackQuery.ID,
        })

        parts := strings.Split(data, "_")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">action := parts[1]
        expenseID, err := strconv.Atoi(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">expense, err := b.expenseRepo.GetByID(ctx, expenseID)
        if err != nil || expense.UserID != userID </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch action </span>{
        case "amount":<span class="cov0" title="0">
                b.promptEditAmount(ctx, tgBot, chatID, messageID, expense)</span>

        case "category":<span class="cov0" title="0">
                b.showCategorySelection(ctx, tgBot, chatID, messageID, expense)</span>
        }
}

// promptEditAmount prompts the user to enter a new amount.
func (b *Bot) promptEditAmount(
        ctx context.Context,
        tgBot *bot.Bot,
        chatID int64,
        messageID int,
        expense *appmodels.Expense,
) <span class="cov0" title="0">{
        // Store pending edit state.
        b.pendingEditsMu.Lock()
        b.pendingEdits[chatID] = &amp;pendingEdit{
                ExpenseID: expense.ID,
                EditType:  "amount",
                MessageID: messageID,
        }
        b.pendingEditsMu.Unlock()

        text := fmt.Sprintf(`üí∞ &lt;b&gt;Edit Amount&lt;/b&gt;

Current amount: $%s SGD

Please type the new amount (e.g., &lt;code&gt;25.50&lt;/code&gt;):`,
                expense.Amount.StringFixed(2))

        keyboard := &amp;models.InlineKeyboardMarkup{
                InlineKeyboard: [][]models.InlineKeyboardButton{
                        {
                                {Text: "‚¨ÖÔ∏è Cancel", CallbackData: fmt.Sprintf("cancel_edit_%d", expense.ID)},
                        },
                },
        }

        _, _ = tgBot.EditMessageText(ctx, &amp;bot.EditMessageTextParams{
                ChatID:      chatID,
                MessageID:   messageID,
                Text:        text,
                ParseMode:   models.ParseModeHTML,
                ReplyMarkup: keyboard,
        })
}</span>

// handlePendingEdit checks for and processes pending edit operations.
func (b *Bot) handlePendingEdit(ctx context.Context, tgBot *bot.Bot, update *models.Update) bool <span class="cov0" title="0">{
        if update.Message == nil || update.Message.Text == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">chatID := update.Message.Chat.ID
        userID := update.Message.From.ID

        b.pendingEditsMu.RLock()
        pending, exists := b.pendingEdits[chatID]
        b.pendingEditsMu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">switch pending.EditType </span>{
        case "amount":<span class="cov0" title="0">
                return b.processAmountEdit(ctx, tgBot, chatID, userID, pending, update.Message.Text)</span>
        case "category":<span class="cov0" title="0">
                return b.processCategoryCreate(ctx, tgBot, chatID, userID, pending, update.Message.Text)</span>
        }

        <span class="cov0" title="0">return false</span>
}

// processAmountEdit processes user input for amount editing.
func (b *Bot) processAmountEdit(
        ctx context.Context,
        tgBot *bot.Bot,
        chatID int64,
        userID int64,
        pending *pendingEdit,
        input string,
) bool <span class="cov0" title="0">{
        // Clear pending edit state.
        b.pendingEditsMu.Lock()
        delete(b.pendingEdits, chatID)
        b.pendingEditsMu.Unlock()

        // Parse the amount.
        input = strings.TrimSpace(input)
        input = strings.TrimPrefix(input, "$")
        input = strings.TrimSpace(input)

        amount, err := parseAmount(input)
        if err != nil </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID:    chatID,
                        Text:      "‚ùå Invalid amount. Please enter a valid number (e.g., 25.50).",
                        ParseMode: models.ParseModeHTML,
                })
                return true
        }</span>

        // Fetch and verify expense ownership.
        <span class="cov0" title="0">expense, err := b.expenseRepo.GetByID(ctx, pending.ExpenseID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Int("expense_id", pending.ExpenseID).Msg("Expense not found for edit")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Expense not found.",
                })
                return true
        }</span>

        <span class="cov0" title="0">if expense.UserID != userID </span><span class="cov0" title="0">{
                logger.Log.Warn().Int64("user_id", userID).Int("expense_id", pending.ExpenseID).Msg("User mismatch on edit")
                return true
        }</span>

        // Update the expense amount.
        <span class="cov0" title="0">expense.Amount = amount
        if err := b.expenseRepo.Update(ctx, expense); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Int("expense_id", expense.ID).Msg("Failed to update amount")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Failed to update amount. Please try again.",
                })
                return true
        }</span>

        <span class="cov0" title="0">logger.Log.Info().
                Int("expense_id", expense.ID).
                Str("new_amount", amount.String()).
                Msg("Amount updated via pending edit")

        // Show updated confirmation message.
        categoryText := categoryUncategorized
        if expense.Category != nil </span><span class="cov0" title="0">{
                categoryText = expense.Category.Name
        }</span> else<span class="cov0" title="0"> if expense.CategoryID != nil </span><span class="cov0" title="0">{
                cat, err := b.categoryRepo.GetByID(ctx, *expense.CategoryID)
                if err == nil </span><span class="cov0" title="0">{
                        categoryText = cat.Name
                }</span>
        }

        <span class="cov0" title="0">keyboard := &amp;models.InlineKeyboardMarkup{
                InlineKeyboard: [][]models.InlineKeyboardButton{
                        {
                                {Text: "‚úÖ Confirm", CallbackData: fmt.Sprintf("receipt_confirm_%d", expense.ID)},
                                {Text: "‚úèÔ∏è Edit", CallbackData: fmt.Sprintf("receipt_edit_%d", expense.ID)},
                                {Text: "‚ùå Cancel", CallbackData: fmt.Sprintf("receipt_cancel_%d", expense.ID)},
                        },
                },
        }

        text := fmt.Sprintf(`üì∏ &lt;b&gt;Amount Updated!&lt;/b&gt;

üí∞ Amount: $%s SGD
üè™ Merchant: %s
üìÅ Category: %s

Amount updated. Confirm to save.`,
                expense.Amount.StringFixed(2),
                expense.Description,
                categoryText)

        // Edit the original message.
        _, _ = tgBot.EditMessageText(ctx, &amp;bot.EditMessageTextParams{
                ChatID:      chatID,
                MessageID:   pending.MessageID,
                Text:        text,
                ParseMode:   models.ParseModeHTML,
                ReplyMarkup: keyboard,
        })

        return true</span>
}

// handleCancelEditCallback handles cancel edit button presses.
func (b *Bot) handleCancelEditCallback(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.CallbackQuery == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">data := update.CallbackQuery.Data
        userID := update.CallbackQuery.From.ID
        chatID := update.CallbackQuery.Message.Message.Chat.ID
        messageID := update.CallbackQuery.Message.Message.ID

        _, _ = tgBot.AnswerCallbackQuery(ctx, &amp;bot.AnswerCallbackQueryParams{
                CallbackQueryID: update.CallbackQuery.ID,
        })

        // Clear any pending edit state.
        b.pendingEditsMu.Lock()
        delete(b.pendingEdits, chatID)
        b.pendingEditsMu.Unlock()

        parts := strings.Split(data, "_")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">expenseID, err := strconv.Atoi(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">expense, err := b.expenseRepo.GetByID(ctx, expenseID)
        if err != nil || expense.UserID != userID </span><span class="cov0" title="0">{
                return
        }</span>

        // Return to edit menu.
        <span class="cov0" title="0">b.handleEditReceipt(ctx, tgBot, chatID, messageID, expense)</span>
}

// showCategorySelection shows category selection buttons.
func (b *Bot) showCategorySelection(
        ctx context.Context,
        tgBot *bot.Bot,
        chatID int64,
        messageID int,
        expense *appmodels.Expense,
) <span class="cov0" title="0">{
        categories, err := b.categoryRepo.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Msg("Failed to fetch categories")
                return
        }</span>

        <span class="cov0" title="0">var rows [][]models.InlineKeyboardButton
        var currentRow []models.InlineKeyboardButton

        for _, cat := range categories </span><span class="cov0" title="0">{
                btn := models.InlineKeyboardButton{
                        Text:         cat.Name,
                        CallbackData: fmt.Sprintf("set_category_%d_%d", expense.ID, cat.ID),
                }
                currentRow = append(currentRow, btn)
                if len(currentRow) == 2 </span><span class="cov0" title="0">{
                        rows = append(rows, currentRow)
                        currentRow = nil
                }</span>
        }
        <span class="cov0" title="0">if len(currentRow) &gt; 0 </span><span class="cov0" title="0">{
                rows = append(rows, currentRow)
        }</span>

        <span class="cov0" title="0">rows = append(rows, []models.InlineKeyboardButton{
                {Text: "‚ûï Create New", CallbackData: fmt.Sprintf("create_category_%d", expense.ID)},
                {Text: "‚¨ÖÔ∏è Back", CallbackData: fmt.Sprintf("receipt_edit_%d", expense.ID)},
        })

        keyboard := &amp;models.InlineKeyboardMarkup{
                InlineKeyboard: rows,
        }

        text := fmt.Sprintf(`üìÅ &lt;b&gt;Select Category&lt;/b&gt;

Current: %s

Choose a new category:`,
                getCategoryName(expense))

        _, _ = tgBot.EditMessageText(ctx, &amp;bot.EditMessageTextParams{
                ChatID:      chatID,
                MessageID:   messageID,
                Text:        text,
                ParseMode:   models.ParseModeHTML,
                ReplyMarkup: keyboard,
        })</span>
}

// getCategoryName returns the category name for an expense.
func getCategoryName(expense *appmodels.Expense) string <span class="cov0" title="0">{
        if expense.Category != nil </span><span class="cov0" title="0">{
                return expense.Category.Name
        }</span>
        <span class="cov0" title="0">return categoryUncategorized</span>
}

// handleSetCategoryCallback handles category selection.
func (b *Bot) handleSetCategoryCallback(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.CallbackQuery == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">data := update.CallbackQuery.Data
        userID := update.CallbackQuery.From.ID
        chatID := update.CallbackQuery.Message.Message.Chat.ID
        messageID := update.CallbackQuery.Message.Message.ID

        _, _ = tgBot.AnswerCallbackQuery(ctx, &amp;bot.AnswerCallbackQueryParams{
                CallbackQueryID: update.CallbackQuery.ID,
        })

        parts := strings.Split(data, "_")
        if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">expenseID, err := strconv.Atoi(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">categoryID, err := strconv.Atoi(parts[3])
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">expense, err := b.expenseRepo.GetByID(ctx, expenseID)
        if err != nil || expense.UserID != userID </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">category, err := b.categoryRepo.GetByID(ctx, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Int("category_id", categoryID).Msg("Category not found")
                return
        }</span>

        <span class="cov0" title="0">expense.CategoryID = &amp;categoryID
        expense.Category = category
        if err := b.expenseRepo.Update(ctx, expense); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Int("expense_id", expense.ID).Msg("Failed to update category")
                return
        }</span>

        <span class="cov0" title="0">logger.Log.Info().
                Int("expense_id", expense.ID).
                Str("category", category.Name).
                Msg("Category updated via callback")

        keyboard := &amp;models.InlineKeyboardMarkup{
                InlineKeyboard: [][]models.InlineKeyboardButton{
                        {
                                {Text: "‚úÖ Confirm", CallbackData: fmt.Sprintf("receipt_confirm_%d", expense.ID)},
                                {Text: "‚úèÔ∏è Edit", CallbackData: fmt.Sprintf("receipt_edit_%d", expense.ID)},
                                {Text: "‚ùå Cancel", CallbackData: fmt.Sprintf("receipt_cancel_%d", expense.ID)},
                        },
                },
        }

        text := fmt.Sprintf(`üì∏ &lt;b&gt;Receipt Updated!&lt;/b&gt;

üí∞ Amount: $%s SGD
üè™ Merchant: %s
üìÅ Category: %s

Category updated. Confirm to save.`,
                expense.Amount.StringFixed(2),
                expense.Description,
                category.Name)

        _, _ = tgBot.EditMessageText(ctx, &amp;bot.EditMessageTextParams{
                ChatID:      chatID,
                MessageID:   messageID,
                Text:        text,
                ParseMode:   models.ParseModeHTML,
                ReplyMarkup: keyboard,
        })</span>
}

// processCategoryCreate processes user input for creating a new category.
func (b *Bot) processCategoryCreate(
        ctx context.Context,
        tgBot *bot.Bot,
        chatID int64,
        userID int64,
        pending *pendingEdit,
        input string,
) bool <span class="cov0" title="0">{
        b.pendingEditsMu.Lock()
        delete(b.pendingEdits, chatID)
        b.pendingEditsMu.Unlock()

        categoryName := strings.TrimSpace(input)
        if categoryName == "" </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Category name cannot be empty.",
                })
                return true
        }</span>

        <span class="cov0" title="0">if len(categoryName) &gt; 50 </span><span class="cov0" title="0">{
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Category name is too long (max 50 characters).",
                })
                return true
        }</span>

        <span class="cov0" title="0">expense, err := b.expenseRepo.GetByID(ctx, pending.ExpenseID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Int("expense_id", pending.ExpenseID).Msg("Expense not found")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Expense not found.",
                })
                return true
        }</span>

        <span class="cov0" title="0">if expense.UserID != userID </span><span class="cov0" title="0">{
                logger.Log.Warn().Int64("user_id", userID).Int("expense_id", pending.ExpenseID).Msg("User mismatch")
                return true
        }</span>

        <span class="cov0" title="0">category, err := b.categoryRepo.Create(ctx, categoryName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Str("name", categoryName).Msg("Failed to create category")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Failed to create category. It may already exist.",
                })
                return true
        }</span>

        <span class="cov0" title="0">expense.CategoryID = &amp;category.ID
        expense.Category = category
        if err := b.expenseRepo.Update(ctx, expense); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error().Err(err).Int("expense_id", expense.ID).Msg("Failed to update expense category")
                _, _ = tgBot.SendMessage(ctx, &amp;bot.SendMessageParams{
                        ChatID: chatID,
                        Text:   "‚ùå Category created but failed to assign it. Please select it from the list.",
                })
                return true
        }</span>

        <span class="cov0" title="0">logger.Log.Info().
                Int("expense_id", expense.ID).
                Int("category_id", category.ID).
                Str("category_name", category.Name).
                Msg("New category created and assigned")

        keyboard := &amp;models.InlineKeyboardMarkup{
                InlineKeyboard: [][]models.InlineKeyboardButton{
                        {
                                {Text: "‚úÖ Confirm", CallbackData: fmt.Sprintf("receipt_confirm_%d", expense.ID)},
                                {Text: "‚úèÔ∏è Edit", CallbackData: fmt.Sprintf("receipt_edit_%d", expense.ID)},
                                {Text: "‚ùå Cancel", CallbackData: fmt.Sprintf("receipt_cancel_%d", expense.ID)},
                        },
                },
        }

        text := fmt.Sprintf(`üì∏ &lt;b&gt;Category Created!&lt;/b&gt;

üí∞ Amount: $%s SGD
üè™ Merchant: %s
üìÅ Category: %s

New category created. Confirm to save.`,
                expense.Amount.StringFixed(2),
                expense.Description,
                category.Name)

        _, _ = tgBot.EditMessageText(ctx, &amp;bot.EditMessageTextParams{
                ChatID:      chatID,
                MessageID:   pending.MessageID,
                Text:        text,
                ParseMode:   models.ParseModeHTML,
                ReplyMarkup: keyboard,
        })

        return true</span>
}

// handleCreateCategoryCallback handles the create new category button press.
func (b *Bot) handleCreateCategoryCallback(ctx context.Context, tgBot *bot.Bot, update *models.Update) <span class="cov0" title="0">{
        if update.CallbackQuery == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">data := update.CallbackQuery.Data
        userID := update.CallbackQuery.From.ID
        chatID := update.CallbackQuery.Message.Message.Chat.ID
        messageID := update.CallbackQuery.Message.Message.ID

        _, _ = tgBot.AnswerCallbackQuery(ctx, &amp;bot.AnswerCallbackQueryParams{
                CallbackQueryID: update.CallbackQuery.ID,
        })

        parts := strings.Split(data, "_")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">expenseID, err := strconv.Atoi(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">expense, err := b.expenseRepo.GetByID(ctx, expenseID)
        if err != nil || expense.UserID != userID </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">b.promptCreateCategory(ctx, tgBot, chatID, messageID, expense)</span>
}

// promptCreateCategory prompts the user to enter a new category name.
func (b *Bot) promptCreateCategory(
        ctx context.Context,
        tgBot *bot.Bot,
        chatID int64,
        messageID int,
        expense *appmodels.Expense,
) <span class="cov0" title="0">{
        b.pendingEditsMu.Lock()
        b.pendingEdits[chatID] = &amp;pendingEdit{
                ExpenseID: expense.ID,
                EditType:  "category",
                MessageID: messageID,
        }
        b.pendingEditsMu.Unlock()

        text := `üìÅ &lt;b&gt;Create New Category&lt;/b&gt;

Please type the name for the new category (e.g., &lt;code&gt;Subscriptions&lt;/code&gt;):`

        keyboard := &amp;models.InlineKeyboardMarkup{
                InlineKeyboard: [][]models.InlineKeyboardButton{
                        {
                                {Text: "‚¨ÖÔ∏è Cancel", CallbackData: fmt.Sprintf("cancel_edit_%d", expense.ID)},
                        },
                },
        }

        _, _ = tgBot.EditMessageText(ctx, &amp;bot.EditMessageTextParams{
                ChatID:      chatID,
                MessageID:   messageID,
                Text:        text,
                ParseMode:   models.ParseModeHTML,
                ReplyMarkup: keyboard,
        })
}</span>
</pre>

		<pre class="file" id="file3" style="display: none">package bot

import (
        "errors"
        "fmt"
        "regexp"
        "strings"

        "github.com/shopspring/decimal"
)

// errInvalidAmount is returned when the amount is zero or negative.
var errInvalidAmount = errors.New("amount must be greater than zero")

// ParsedExpense represents a parsed expense from user input.
type ParsedExpense struct {
        Amount       decimal.Decimal
        Description  string
        CategoryName string
}

// amountRegex matches amounts like "5", "5.50", "5,50".
var amountRegex = regexp.MustCompile(`^(\d+(?:[.,]\d{1,2})?)`)

// parseAmount parses a string into a decimal amount.
func parseAmount(input string) (decimal.Decimal, error) <span class="cov8" title="1">{
        input = strings.TrimSpace(input)
        input = strings.ReplaceAll(input, ",", ".")

        amount, err := decimal.NewFromString(input)
        if err != nil </span><span class="cov8" title="1">{
                return decimal.Zero, fmt.Errorf("invalid amount format: %w", err)
        }</span>

        <span class="cov8" title="1">if amount.LessThanOrEqual(decimal.Zero) </span><span class="cov8" title="1">{
                return decimal.Zero, errInvalidAmount
        }</span>

        <span class="cov8" title="1">return amount, nil</span>
}

// ParseExpenseInput parses free-text expense input like "5.50 Coffee" or "10 Lunch Food - Dining Out".
// Returns nil if the input cannot be parsed as an expense.
func ParseExpenseInput(input string) *ParsedExpense <span class="cov8" title="1">{
        input = strings.TrimSpace(input)
        if input == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">match := amountRegex.FindString(input)
        if match == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">match = strings.ReplaceAll(match, ",", ".")
        amount, err := decimal.NewFromString(match)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if amount.LessThanOrEqual(decimal.Zero) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">rest := strings.TrimSpace(input[len(match):])
        if rest == "" </span><span class="cov8" title="1">{
                return &amp;ParsedExpense{
                        Amount:      amount,
                        Description: "",
                }
        }</span>

        <span class="cov8" title="1">return &amp;ParsedExpense{
                Amount:      amount,
                Description: extractDescription(rest),
        }</span>
}

// extractDescription extracts the description from the input.
// Category matching is handled separately in ParseAddCommandWithCategories.
func extractDescription(input string) string <span class="cov8" title="1">{
        return strings.TrimSpace(input)
}</span>

// ParseAddCommand parses the /add command format: /add &lt;amount&gt; &lt;description&gt; [category].
// Category can be multi-word like "Food - Dining Out".
func ParseAddCommand(input string) *ParsedExpense <span class="cov8" title="1">{
        input = strings.TrimPrefix(input, "/add")
        input = strings.TrimSpace(input)

        idx := strings.Index(input, "@")
        if idx != -1 </span><span class="cov8" title="1">{
                spaceIdx := strings.Index(input, " ")
                if spaceIdx != -1 &amp;&amp; spaceIdx &gt; idx </span><span class="cov8" title="1">{
                        input = strings.TrimSpace(input[spaceIdx:])
                }</span> else<span class="cov8" title="1"> if spaceIdx == -1 </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return ParseExpenseInput(input)</span>
}

// ParseAddCommandWithCategories parses /add with category matching.
// It tries to match the longest category name from the end of the input.
func ParseAddCommandWithCategories(input string, categoryNames []string) *ParsedExpense <span class="cov8" title="1">{
        parsed := ParseAddCommand(input)
        if parsed == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if parsed.Description == "" </span><span class="cov8" title="1">{
                return parsed
        }</span>

        <span class="cov8" title="1">descLower := strings.ToLower(parsed.Description)
        var matchedCategory string
        var matchedLen int

        for _, catName := range categoryNames </span><span class="cov8" title="1">{
                catLower := strings.ToLower(catName)
                if strings.HasSuffix(descLower, catLower) </span><span class="cov8" title="1">{
                        if len(catName) &gt; matchedLen </span><span class="cov8" title="1">{
                                matchedCategory = catName
                                matchedLen = len(catName)
                        }</span>
                }
        }

        <span class="cov8" title="1">if matchedCategory != "" </span><span class="cov8" title="1">{
                descWithoutCat := strings.TrimSpace(parsed.Description[:len(parsed.Description)-matchedLen])
                parsed.Description = descWithoutCat
                parsed.CategoryName = matchedCategory
        }</span>

        <span class="cov8" title="1">return parsed</span>
}

// ParseExpenseInputWithCategories parses free-text with category matching.
func ParseExpenseInputWithCategories(input string, categoryNames []string) *ParsedExpense <span class="cov8" title="1">{
        parsed := ParseExpenseInput(input)
        if parsed == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if parsed.Description == "" </span><span class="cov8" title="1">{
                return parsed
        }</span>

        <span class="cov8" title="1">descLower := strings.ToLower(parsed.Description)
        var matchedCategory string
        var matchedLen int

        for _, catName := range categoryNames </span><span class="cov8" title="1">{
                catLower := strings.ToLower(catName)
                if strings.HasSuffix(descLower, catLower) </span><span class="cov8" title="1">{
                        if len(catName) &gt; matchedLen </span><span class="cov8" title="1">{
                                matchedCategory = catName
                                matchedLen = len(catName)
                        }</span>
                }
        }

        <span class="cov8" title="1">if matchedCategory != "" </span><span class="cov8" title="1">{
                descWithoutCat := strings.TrimSpace(parsed.Description[:len(parsed.Description)-matchedLen])
                parsed.Description = descWithoutCat
                parsed.CategoryName = matchedCategory
        }</span>

        <span class="cov8" title="1">return parsed</span>
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
